File.import "../../TacticLib.ist";
File.import "../Syntax/Syntax.ist";

openModule /Prelude/;
openModule /CalfSyn/;

beginModule "PlusStep";

File.import "Tpv.ist";
File.import "Tpc.ist";
File.import "Tmv.ist";
File.import "U.ist";
File.import "Step.ist";

openModule /Tpv/;
openModule /Tpc/;
openModule /Tmv/;
openModule /U/;
openModule /Step/;

define /PLUS_STEP_TERM {M B} G L i X/
/
    (Glue.pi_closed X) #2 #2 #2 #1
//
    forall
        (M : intersect i . PhaseSig i)
        (B : intersect i . BehSig i)
        (G : intersect i . Glue.GLUE_CM M i)
        (L : `SynM M -> intersect i . `Sig B i) .
    forall (i : level) .
    forall (X : Ext.wk (TPC G L i)) .
    forall (n m : nat) .
    forall (e : Ext.wk (TMV G L i) ((Ext.wk (UU G L i)) X)) .
    STEP G L i X (n + m) e = STEP G L i X n (STEP G L i X m e) : _
/;
unfold /PLUS_STEP_TERM/.
inference.
introOf /M B G L i X/.
reduce //.

unfold /TPC in X/.
unfold /TPC_Sem in X/.
unfold /Ext.wk in X/.

assert /forall (x : forall (z : SynM) . tpv) . isClosedModalM M (TPV_Sem L i x)/ /tpvClosed/.
{
    inference.
    apply /TPV_Sem_isClosedModal/.
}

assert /forall (x : forall (z : SynM) . tpc) . isClosedModalM M (TPC_Sem L i x)/ /tpcClosed/.
{
    inference.
    apply /TPC_Sem_isClosedModal/.
}

unfold /TPC_Sem in tpcClosed/.

infer /Glue.pi_closed X/ /PiClosedXTp/.


assert /forall (z : `SynM M) . Glue.pi_closed X = SynAlg L i z (Glue.pi_open X z) : CostAlg i/ /HeqPiClosed/.
{
    inference.
    intro /z/.
    soRaw /Ext.syn_eq (Ext.S' (CostAlg i) (fn z . SynAlg L i z (Glue.pi_open X z))) (Glue.pi_closed X) z/ /eqClosed/.
    6:{
        inference.
        typecheck. 
        {
            reflexivity.
        }
    }
    typecheck_goals [7, 4, 3, 2, 1];
    2:{
        auto.
    }
    1:{
        reduce //.
        typecheck. 
        {
            reflexivity.
        }
    }
    unfold /Ext.pt in eqClosed/.
    subsume /Ext.t
         (Ext.S'
            (CostAlg i)
            (fn z1 . SynAlg L i z1 (Glue.pi_open X z1)))/.
    {
        apply /Ext.subtype/.
        {
            reflexivity.
        }
        reflexivity.
    }
    auto. 
}

assert /forall (z : `SynM M) . Glue.pi_closed X #1 = tmv (U' (Glue.pi_open X z)) : _/ /proj1Eq/.
{
    inference.
    intro /z/.
    transitivity /SynAlg L i z (Glue.pi_open X z) #1/.
    1:{
        unfold /SynAlg/.
        reflexivity.
        reflexivity.
    }
    {
        inference.
        rememberRaw /Glue.pi_closed X/ /`CostAlg B i/ /q1/ /p1/.
        {
            subsume /Ext.t (Ext.S' (CostAlg i) (fn z . SynAlg L i z (Glue.pi_open X z)))/.
            {
                apply /Ext.subtype/.
                {
                    reflexivity.
                }
                reflexivity.
            }
            auto. 
        }
        rememberRaw /SynAlg L i z (Glue.pi_open X z)/ /`CostAlg B i/ /q2/ /p2/.
        {
            typecheck. 
            reflexivity.
        }                
        decompEq 1 /(exists 
                    (C : U i)
                    (sstep : nat -> C -> C)
                    (sstep_zero : forall (x : C) . sstep 0 x = x : C)
                    (sstep_plus
                       : forall (n m : nat) (x : C) .
                           sstep (n + m) x = sstep n (sstep m x) : C)
                    (sstep_beh : forall (n : nat) (x : C) . beh -> sstep n x = x : C) .
                    unit)/.
        etransitivity.
        {
            unfold /CostAlg in p1/.
            hyp /p1/.
        }
        {
            etransitivity.
            {
                unfold /CostAlg in HeqPiClosed/.
                apply /HeqPiClosed z/.                        
            }
            symmetry.
            unfold /CostAlg in p2/.
            auto. 
        }
    }
}

assert /Glue.t
  (G
     (fn z1 . tpc)
     (fn X1 . Ext.t (Ext.S' (CostAlg i) (fn z1 . SynAlg L i z1 (X1 z1)))))
  = Ext.wk (TPC G L i)
  : U (1 + i)/ /HeqTPC/.
{
    unfold /TPC, TPC_Sem, Ext.wk/.
    reflexivity.
}

assert /Glue.pi_closed X #1 : TPV_Sem L i (fn z . U' (TPC_open z X))/ /piClosed/.
{
    inference.
    unfold /TPV_Sem/.
    reduce //.
    infer /Glue.pi_closed X/ /piClosedTy/.
    reduce /piClosedTy/.
    applyRaw /`Ext.intro M (lsucc i) (fn z . U i) (U i) (fn z . `tmv B (L z) (U' (TPC_open z X))) _ (Glue.pi_closed X #1) / >> auto.
    {
        intro /z _/.
        infer /`TPC_open M B G L ap i z X/ /TPC_openTp/.
        unfold /ap in TPC_openTp/.
        reduce //.
        etransitivity.
        {
            apply /proj1Eq z/.
        }
        rewriteRaw /-> Glue.syn_eq _ z/.
        typecheck_goals [7, 6, 5, 4, 3, 2, 1, 0];
        fold /TPC_open z X/.
        reflexivity.
    }
}

eqtp /forall (n m : nat) (e : (Glue.pi_closed X #1)) . (Glue.pi_closed X #2 #1) (n + m) e = (Glue.pi_closed X #2 #1) n ((Glue.pi_closed X #2 #1) m e): (Glue.pi_closed X #1)/.
1:{
    typecheck.
}
unfold /STEP at all/.
typecheck. 
{
    unfold /TMV, UU, Ext.wk at all/.
    rewriteRaw /-> Glue.beta2/.
    5:{
        inference.
        typecheck. 
    }
    typecheck_goals [6, 5, 4, 3, 2, 1];
    {
        typecheck.
        unfold /TPV_Sem/.
        apply /Ext.subtype/.
    }
    reflexivity.
}
{
    unfold /TMV, UU, Ext.wk at all/.
    rewriteRaw /-> Glue.beta2/.
    5:{
        inference.
        typecheck. 
    }
    typecheck_goals [6, 5, 4, 3, 2, 1];
    {
        typecheck.
        unfold /TPV_Sem/.
        apply /Ext.subtype/.
    }
    reflexivity.
}
qed ();

lemma "PLUS_STEP"
/
    forall
        (M : intersect i . PhaseSig i)
        (B : intersect i . BehSig i)
        (G : intersect i . Glue.GLUE_CM M i) 
        (L : `SynM M -> intersect i . `Sig B i) .
    forall (i : level) .
    forall (X : Ext.wk (TPC G L i)) .
    forall (n m : nat) .
    forall (e : Ext.wk (TMV G L i) ((Ext.wk (UU G L i)) X)) .
    STEP G L i X (n + m) e = STEP G L i X n (STEP G L i X m e) : _
/;
inference.
intro /M B G L i X n m e/.
apply /PLUS_STEP_TERM/.
qed ();


endModule ();
